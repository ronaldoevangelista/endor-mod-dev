"use strict";

const fs_extra_p_1 = require("fs-extra-p");
const path = require("path");
const os_1 = require("os");
const util_1 = require("../util/util");
const bluebird_1 = require("bluebird");
//noinspection JSUnusedLocalSymbols
const __awaiter = require("../util/awaiter");
exports.installPrefix = "/opt";
class LinuxTargetHelper {
    constructor(packager, cleanupTasks) {
        this.packager = packager;
        this.maxIconPath = null;
        const tempDir = path.join(os_1.tmpdir(), util_1.getTempName("electron-builder-linux"));
        this.tempDirPromise = fs_extra_p_1.emptyDir(tempDir).then(() => {
            cleanupTasks.push(() => fs_extra_p_1.remove(tempDir));
            return tempDir;
        });
        this.icons = this.computeDesktopIcons();
    }
    // must be name without spaces and other special characters, but not product name used
    computeDesktopIcons() {
        return __awaiter(this, void 0, void 0, function* () {
            const tempDir = yield this.tempDirPromise;
            try {
                const mappings = [];
                const pngIconsDir = path.join(this.packager.buildResourcesDir, "icons");
                let maxSize = 0;
                for (let file of yield fs_extra_p_1.readdir(pngIconsDir)) {
                    if (file.endsWith(".png") || file.endsWith(".PNG")) {
                        // If parseInt encounters a character that is not a numeral in the specified radix,
                        // it returns the integer value parsed up to that point
                        try {
                            const size = parseInt(file, 10);
                            if (size > 0) {
                                const iconPath = `${ pngIconsDir }/${ file }`;
                                mappings.push([iconPath, `${ size }x${ size }/apps/${ this.packager.appInfo.name }.png`]);
                                if (size > maxSize) {
                                    maxSize = size;
                                    this.maxIconPath = iconPath;
                                }
                            }
                        } catch (e) {
                            console.error(e);
                        }
                    }
                }
                return mappings;
            } catch (e) {
                return this.createFromIcns(tempDir);
            }
        });
    }
    computeDesktopEntry(exec, extra) {
        return __awaiter(this, void 0, void 0, function* () {
            const appInfo = this.packager.appInfo;
            const custom = this.packager.platformSpecificBuildOptions.desktop;
            if (custom != null) {
                return custom;
            }
            const productFilename = appInfo.productFilename;
            const tempFile = path.join((yield this.tempDirPromise), `${ productFilename }.desktop`);
            yield fs_extra_p_1.outputFile(tempFile, this.packager.platformSpecificBuildOptions.desktop || `[Desktop Entry]
Name=${ appInfo.productName }
Comment=${ this.packager.platformSpecificBuildOptions.description || appInfo.description }
Exec=${ exec == null ? `"${ exports.installPrefix }/${ productFilename }/${ productFilename }"` : exec }
Terminal=false
Type=Application
Icon=${ appInfo.name }
${ extra == null ? "" : `${ extra }\n` }`);
            return tempFile;
        });
    }
    createFromIcns(tempDir) {
        return __awaiter(this, void 0, void 0, function* () {
            const output = yield util_1.exec("icns2png", ["-x", "-o", tempDir, path.join(this.packager.buildResourcesDir, "icon.icns")]);
            util_1.debug(output);
            //noinspection UnnecessaryLocalVariableJS
            const imagePath = path.join(tempDir, "icon_256x256x32.png");
            this.maxIconPath = imagePath;
            function resize(size) {
                const sizeArg = `${ size }x${ size }`;
                return util_1.exec("gm", ["convert", "-size", sizeArg, imagePath, "-resize", sizeArg, path.join(tempDir, `icon_${ size }x${ size }x32.png`)]);
            }
            const promises = [resize(24), resize(96)];
            if (!(output.indexOf("is32") !== -1)) {
                promises.push(resize(16));
            }
            if (!(output.indexOf("ih32") !== -1)) {
                promises.push(resize(48));
            }
            if (!(output.toString().indexOf("icp6") !== -1)) {
                promises.push(resize(64));
            }
            if (!(output.indexOf("it32") !== -1)) {
                promises.push(resize(128));
            }
            yield bluebird_1.Promise.all(promises);
            const appName = this.packager.appInfo.name;
            function createMapping(size) {
                return [`${ tempDir }/icon_${ size }x${ size }x32.png`, `${ size }x${ size }/apps/${ appName }.png`];
            }
            return [createMapping("16"), createMapping("24"), createMapping("32"), createMapping("48"), createMapping("64"), createMapping("96"), createMapping("128"), createMapping("256"), createMapping("512")];
        });
    }
}
exports.LinuxTargetHelper = LinuxTargetHelper;
//# sourceMappingURL=LinuxTargetHelper.js.map